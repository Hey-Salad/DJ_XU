{
  "version": 3,
  "sources": ["../bundle-nkkSe7/strip-cf-connecting-ip-header.js", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-nkkSe7/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-nkkSe7/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/chilumbam/dj-xu/cloudflare-worker/.wrangler/tmp/dev-Mp3pfX",
  "sourcesContent": ["function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/**\n * Cloudflare Worker proxy for DeepSeek chat completions.\n * Accepts the front-end AIRequest shape and returns AIResponse.\n */\n\ninterface AIRequest {\n  input: string;\n  context?: {\n    currentTrack?: string;\n    conversationHistory?: string[];\n    userPreferences?: Record<string, unknown>;\n  };\n}\n\ninterface AIResponse {\n  content: string;\n  metadata: {\n    confidence?: number;\n    source: 'deepseek';\n    timestamp: number;\n  };\n}\n\ninterface Env {\n  DEEPSEEK_API_KEY: string;\n  DEEPSEEK_API_BASE?: string;\n  DEEPSEEK_MODEL?: string;\n  ELEVENLABS_API_KEY?: string;\n  ELEVENLABS_VOICE_ID?: string;\n  ELEVENLABS_MODEL?: string;\n  ELEVENLABS_API_BASE?: string;\n  SUPABASE_URL?: string;\n  SUPABASE_SERVICE_KEY?: string;\n}\n\nconst DEFAULT_MODEL = 'deepseek-chat';\nconst DEFAULT_BASE = 'https://api.deepseek.com';\n\nconst personaPrimer = `You are DJ XU, a charismatic British-Hong Kong AI DJ who keeps\nthe energy high, mixes Cantonese cultural references with global club\nvibes, and offers concise but animated guidance to listeners. Lean into\nmusic knowledge, highlight track transitions when the context provides a\ncurrent song, and keep things friendly and hype.`;\n\nconst CORS_HEADERS: Record<string, string> = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'POST,OPTIONS',\n  'Access-Control-Allow-Headers': 'content-type,authorization',\n};\n\ntype ChatMessage = { role: 'system' | 'user' | 'assistant'; content: string };\n\ninterface ChainedAIRequest extends AIRequest {\n  voiceId?: string;\n  voiceModel?: string;\n  voiceSettings?: Record<string, unknown>;\n}\n\ninterface ElevenLabsResponse {\n  audioBase64: string;\n  contentType: string;\n}\n\ninterface BroadcastStartRequest {\n  performanceSessionId: string;\n  maxViewers?: number;\n  captionLanguage?: string;\n  enableTranslations?: boolean;\n}\n\ninterface BroadcastStartResponse {\n  broadcastId: string;\n  broadcastToken: string;\n  shareUrl: string;\n}\n\ninterface BroadcastCaptionRequest {\n  broadcastToken: string;\n  text: string;\n  speaker?: 'DJ_XU' | 'USER' | 'SYSTEM';\n  audioUrl?: string;\n  detectedLanguage?: string;\n  confidence?: number;\n}\n\ninterface BroadcastStatusRequest {\n  broadcastToken: string;\n}\n\ninterface BroadcastTrackRequest {\n  broadcastToken: string;\n  track: {\n    name: string;\n    artist: string;\n    album?: string;\n    albumArtUrl?: string;\n    id?: string;\n  };\n}\n\nfunction buildMessages(request: AIRequest): ChatMessage[] {\n  const messages: ChatMessage[] = [\n    { role: 'system', content: personaPrimer },\n    { role: 'user', content: request.input },\n  ];\n\n  if (request.context) {\n    const contextParts: string[] = [];\n\n    if (request.context.currentTrack) {\n      contextParts.push(`Currently playing: ${request.context.currentTrack}`);\n    }\n\n    if (request.context.conversationHistory?.length) {\n      contextParts.push(\n        `Conversation history:\\n${request.context.conversationHistory.join('\\n')}`\n      );\n    }\n\n    if (request.context.userPreferences) {\n      contextParts.push(\n        `User preferences: ${JSON.stringify(request.context.userPreferences)}`\n      );\n    }\n\n    if (contextParts.length) {\n      messages.push({\n        role: 'system',\n        content: contextParts.join('\\n'),\n      });\n    }\n  }\n\n  return messages;\n}\n\nasync function callDeepSeek(env: Env, request: AIRequest): Promise<AIResponse> {\n  if (!env.DEEPSEEK_API_KEY) {\n    throw new Error('DEEPSEEK_API_KEY is not configured');\n  }\n\n  const baseUrl = env.DEEPSEEK_API_BASE ?? DEFAULT_BASE;\n  const model = env.DEEPSEEK_MODEL ?? DEFAULT_MODEL;\n\n  const response = await fetch(`${baseUrl}/v1/chat/completions`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${env.DEEPSEEK_API_KEY}`,\n    },\n    body: JSON.stringify({\n      model,\n      temperature: 0.85,\n      max_tokens: 800,\n      messages: buildMessages(request),\n    }),\n  });\n\n  if (!response.ok) {\n    const errorBody = await response.text();\n    throw new Error(\n      `DeepSeek request failed (${response.status}): ${errorBody}`\n    );\n  }\n\n  const data = await response.json();\n  const content =\n    data?.choices?.[0]?.message?.content ??\n    'I could not retrieve a response from DeepSeek.';\n\n  return {\n    content,\n    metadata: {\n      source: 'deepseek',\n      timestamp: Date.now(),\n      confidence: data?.choices?.[0]?.confidence,\n    },\n  };\n}\n\nfunction jsonResponse(body: unknown, init?: ResponseInit): Response {\n  return new Response(JSON.stringify(body), {\n    ...init,\n    headers: {\n      'Content-Type': 'application/json',\n      ...CORS_HEADERS,\n      ...(init?.headers ?? {}),\n    },\n  });\n}\n\nfunction arrayBufferToBase64(buffer: ArrayBuffer): string {\n  const bytes = new Uint8Array(buffer);\n  const chunkSize = 0x8000;\n  let binary = '';\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));\n  }\n  return btoa(binary);\n}\n\nasync function callElevenLabs(\n  env: Env,\n  text: string,\n  voiceId?: string,\n  voiceModel?: string,\n  voiceSettings?: Record<string, unknown>\n): Promise<ElevenLabsResponse> {\n  const baseUrl = env.ELEVENLABS_API_BASE ?? 'https://api.elevenlabs.io/v1';\n  const apiKey = env.ELEVENLABS_API_KEY;\n  const resolvedVoiceId = voiceId ?? env.ELEVENLABS_VOICE_ID;\n  const resolvedModel = voiceModel ?? env.ELEVENLABS_MODEL ?? 'eleven_v3';\n\n  if (!apiKey) {\n    throw new Error('ELEVENLABS_API_KEY is required for text-to-speech.');\n  }\n  if (!resolvedVoiceId) {\n    throw new Error('ELEVENLABS_VOICE_ID is required for text-to-speech.');\n  }\n\n  const response = await fetch(\n    `${baseUrl}/text-to-speech/${resolvedVoiceId}`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'audio/mpeg',\n        'xi-api-key': apiKey,\n      },\n      body: JSON.stringify({\n        text,\n        model: resolvedModel,\n        voice_settings: voiceSettings ?? {},\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const body = await response.text();\n    throw new Error(\n      `ElevenLabs request failed (${response.status}): ${body.slice(0, 1024)}`\n    );\n  }\n\n  const arrayBuffer = await response.arrayBuffer();\n  const contentType = response.headers.get('Content-Type') ?? 'audio/mpeg';\n  return {\n    audioBase64: arrayBufferToBase64(arrayBuffer),\n    contentType,\n  };\n}\n\nasync function startBroadcast(\n  env: Env,\n  request: BroadcastStartRequest\n): Promise<BroadcastStartResponse> {\n  if (!env.SUPABASE_URL || !env.SUPABASE_SERVICE_KEY) {\n    throw new Error('Supabase configuration is missing');\n  }\n\n  const { performanceSessionId, maxViewers = 10, captionLanguage = 'en', enableTranslations = true } = request;\n\n  const response = await fetch(`${env.SUPABASE_URL}/rest/v1/broadcast_sessions`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'apikey': env.SUPABASE_SERVICE_KEY,\n      'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,\n      'Prefer': 'return=representation'\n    },\n    body: JSON.stringify({\n      id: performanceSessionId,\n      max_viewers: maxViewers,\n      caption_language: captionLanguage,\n      enable_translations: enableTranslations,\n      status: 'live',\n      started_at: new Date().toISOString()\n    })\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`Failed to create broadcast session: ${error}`);\n  }\n\n  const [data] = await response.json();\n  const broadcastToken = data.broadcast_token;\n\n  return {\n    broadcastId: performanceSessionId,\n    broadcastToken,\n    shareUrl: `${new URL(env.SUPABASE_URL).origin}/watch/${broadcastToken}`\n  };\n}\n\nasync function sendCaption(\n  env: Env,\n  request: BroadcastCaptionRequest\n): Promise<{ success: boolean; captionId?: number }> {\n  if (!env.SUPABASE_URL || !env.SUPABASE_SERVICE_KEY) {\n    throw new Error('Supabase configuration is missing');\n  }\n\n  const { broadcastToken, text, speaker = 'DJ_XU', audioUrl, detectedLanguage, confidence } = request;\n\n  const sessionResponse = await fetch(\n    `${env.SUPABASE_URL}/rest/v1/broadcast_sessions?broadcast_token=eq.${broadcastToken}&select=id,status`,\n    {\n      headers: {\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`\n      }\n    }\n  );\n\n  if (!sessionResponse.ok) {\n    throw new Error('Failed to validate broadcast token');\n  }\n\n  const sessions = await sessionResponse.json();\n  if (!sessions.length || sessions[0].status !== 'live') {\n    throw new Error('Broadcast is not active');\n  }\n\n  const broadcastId = sessions[0].id;\n\n  const countResponse = await fetch(\n    `${env.SUPABASE_URL}/rest/v1/live_captions?broadcast_session_id=eq.${broadcastId}&select=sequence_number&order=sequence_number.desc&limit=1`,\n    {\n      headers: {\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`\n      }\n    }\n  );\n\n  const lastCaptions = await countResponse.json();\n  const sequenceNumber = lastCaptions.length ? lastCaptions[0].sequence_number + 1 : 1;\n\n  const captionResponse = await fetch(`${env.SUPABASE_URL}/rest/v1/live_captions`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'apikey': env.SUPABASE_SERVICE_KEY,\n      'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,\n      'Prefer': 'return=representation'\n    },\n    body: JSON.stringify({\n      broadcast_session_id: broadcastId,\n      sequence_number: sequenceNumber,\n      speaker,\n      original_text: text,\n      detected_language: detectedLanguage,\n      confidence,\n      timestamp_ms: Date.now(),\n      audio_url: audioUrl\n    })\n  });\n\n  if (!captionResponse.ok) {\n    const error = await captionResponse.text();\n    throw new Error(`Failed to send caption: ${error}`);\n  }\n\n  const [caption] = await captionResponse.json();\n\n  return {\n    success: true,\n    captionId: caption.id\n  };\n}\n\nasync function endBroadcast(\n  env: Env,\n  broadcastToken: string\n): Promise<{ success: boolean }> {\n  if (!env.SUPABASE_URL || !env.SUPABASE_SERVICE_KEY) {\n    throw new Error('Supabase configuration is missing');\n  }\n\n  const response = await fetch(\n    `${env.SUPABASE_URL}/rest/v1/broadcast_sessions?broadcast_token=eq.${broadcastToken}`,\n    {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json',\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`\n      },\n      body: JSON.stringify({\n        status: 'ended',\n        ended_at: new Date().toISOString()\n      })\n    }\n  );\n\n  if (!response.ok) {\n    throw new Error('Failed to end broadcast');\n  }\n\n  return { success: true };\n}\n\nasync function getBroadcastStatus(\n  env: Env,\n  broadcastToken: string\n): Promise<any> {\n  if (!env.SUPABASE_URL || !env.SUPABASE_SERVICE_KEY) {\n    throw new Error('Supabase configuration is missing');\n  }\n\n  const response = await fetch(\n    `${env.SUPABASE_URL}/rest/v1/rpc/get_broadcast_by_token`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`\n      },\n      body: JSON.stringify({ token: broadcastToken })\n    }\n  );\n\n  if (!response.ok) {\n    throw new Error('Failed to get broadcast status');\n  }\n\n  const data = await response.json();\n  return data.length ? data[0] : null;\n}\n\nasync function broadcastTrack(\n  env: Env,\n  request: BroadcastTrackRequest\n): Promise<{ success: boolean; trackId?: number }> {\n  if (!env.SUPABASE_URL || !env.SUPABASE_SERVICE_KEY) {\n    throw new Error('Supabase configuration is missing');\n  }\n\n  const { broadcastToken, track } = request;\n\n  // Get broadcast session\n  const sessionResponse = await fetch(\n    `${env.SUPABASE_URL}/rest/v1/broadcast_sessions?broadcast_token=eq.${broadcastToken}&select=id,status`,\n    {\n      headers: {\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`\n      }\n    }\n  );\n\n  if (!sessionResponse.ok) {\n    throw new Error('Failed to validate broadcast token');\n  }\n\n  const sessions = await sessionResponse.json();\n  if (!sessions.length || sessions[0].status !== 'live') {\n    throw new Error('Broadcast is not active');\n  }\n\n  const broadcastId = sessions[0].id;\n\n  // End previous track if exists\n  await fetch(\n    `${env.SUPABASE_URL}/rest/v1/broadcast_tracks?broadcast_session_id=eq.${broadcastId}&ended_at=is.null`,\n    {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json',\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`\n      },\n      body: JSON.stringify({\n        ended_at: new Date().toISOString()\n      })\n    }\n  );\n\n  // Insert new track\n  const trackResponse = await fetch(`${env.SUPABASE_URL}/rest/v1/broadcast_tracks`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'apikey': env.SUPABASE_SERVICE_KEY,\n      'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,\n      'Prefer': 'return=representation'\n    },\n    body: JSON.stringify({\n      broadcast_session_id: broadcastId,\n      track_name: track.name,\n      artist: track.artist,\n      album: track.album,\n      album_art_url: track.albumArtUrl,\n      source: 'spotify',\n      source_track_id: track.id\n    })\n  });\n\n  if (!trackResponse.ok) {\n    const error = await trackResponse.text();\n    throw new Error(`Failed to broadcast track: ${error}`);\n  }\n\n  const [trackData] = await trackResponse.json();\n\n  return {\n    success: true,\n    trackId: trackData.id\n  };\n}\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n\n    if (request.method === 'OPTIONS') {\n      return new Response(null, { status: 204, headers: CORS_HEADERS });\n    }\n\n    if (url.pathname === '/api/deepseek') {\n      if (request.method !== 'POST') {\n        return jsonResponse({ error: 'Method not allowed' }, { status: 405 });\n      }\n\n      try {\n        const payload = (await request.json()) as AIRequest;\n        const aiResponse = await callDeepSeek(env, payload);\n        return jsonResponse(aiResponse);\n      } catch (error) {\n        console.error('DeepSeek worker error:', error);\n        const message =\n          error instanceof Error ? error.message : 'Unknown error occurred';\n        return jsonResponse({ error: message }, { status: 500 });\n      }\n    }\n\n    if (url.pathname === '/api/ai') {\n      if (request.method !== 'POST') {\n        return jsonResponse({ error: 'Method not allowed' }, { status: 405 });\n      }\n\n      try {\n        const payload = (await request.json()) as ChainedAIRequest;\n        const aiResponse = await callDeepSeek(env, payload);\n        const ttsResponse = await callElevenLabs(\n          env,\n          aiResponse.content,\n          payload.voiceId,\n          payload.voiceModel,\n          payload.voiceSettings\n        );\n\n        return jsonResponse({\n          deepseek: aiResponse,\n          audio: {\n            base64: ttsResponse.audioBase64,\n            contentType: ttsResponse.contentType,\n          },\n        });\n      } catch (error) {\n        console.error('Chained AI worker error:', error);\n        const message =\n          error instanceof Error ? error.message : 'Unknown error occurred';\n        return jsonResponse({ error: message }, { status: 500 });\n      }\n    }\n\n    if (url.pathname === '/api/broadcast/start') {\n      if (request.method !== 'POST') {\n        return jsonResponse({ error: 'Method not allowed' }, { status: 405 });\n      }\n\n      try {\n        const payload = (await request.json()) as BroadcastStartRequest;\n        const result = await startBroadcast(env, payload);\n        return jsonResponse(result);\n      } catch (error) {\n        console.error('Start broadcast error:', error);\n        const message = error instanceof Error ? error.message : 'Unknown error occurred';\n        return jsonResponse({ error: message }, { status: 500 });\n      }\n    }\n\n    if (url.pathname === '/api/broadcast/caption') {\n      if (request.method !== 'POST') {\n        return jsonResponse({ error: 'Method not allowed' }, { status: 405 });\n      }\n\n      try {\n        const payload = (await request.json()) as BroadcastCaptionRequest;\n        const result = await sendCaption(env, payload);\n        return jsonResponse(result);\n      } catch (error) {\n        console.error('Send caption error:', error);\n        const message = error instanceof Error ? error.message : 'Unknown error occurred';\n        return jsonResponse({ error: message }, { status: 500 });\n      }\n    }\n\n    if (url.pathname === '/api/broadcast/end') {\n      if (request.method !== 'POST') {\n        return jsonResponse({ error: 'Method not allowed' }, { status: 405 });\n      }\n\n      try {\n        const { broadcastToken } = (await request.json()) as { broadcastToken: string };\n        const result = await endBroadcast(env, broadcastToken);\n        return jsonResponse(result);\n      } catch (error) {\n        console.error('End broadcast error:', error);\n        const message = error instanceof Error ? error.message : 'Unknown error occurred';\n        return jsonResponse({ error: message }, { status: 500 });\n      }\n    }\n\n    if (url.pathname === '/api/broadcast/status') {\n      if (request.method !== 'POST') {\n        return jsonResponse({ error: 'Method not allowed' }, { status: 405 });\n      }\n\n      try {\n        const { broadcastToken } = (await request.json()) as BroadcastStatusRequest;\n        const result = await getBroadcastStatus(env, broadcastToken);\n        if (!result) {\n          return jsonResponse({ error: 'Broadcast not found' }, { status: 404 });\n        }\n        return jsonResponse(result);\n      } catch (error) {\n        console.error('Get broadcast status error:', error);\n        const message = error instanceof Error ? error.message : 'Unknown error occurred';\n        return jsonResponse({ error: message }, { status: 500 });\n      }\n    }\n\n    if (url.pathname === '/api/broadcast/track') {\n      if (request.method !== 'POST') {\n        return jsonResponse({ error: 'Method not allowed' }, { status: 405 });\n      }\n\n      try {\n        const payload = (await request.json()) as BroadcastTrackRequest;\n        const result = await broadcastTrack(env, payload);\n        return jsonResponse(result);\n      } catch (error) {\n        console.error('Broadcast track error:', error);\n        const message = error instanceof Error ? error.message : 'Unknown error occurred';\n        return jsonResponse({ error: message }, { status: 500 });\n      }\n    }\n\n    return new Response('Not Found', { status: 404, headers: CORS_HEADERS });\n  },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/chilumbam/dj-xu/cloudflare-worker/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/chilumbam/dj-xu/cloudflare-worker/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/chilumbam/dj-xu/cloudflare-worker/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/chilumbam/dj-xu/cloudflare-worker/src/index.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/chilumbam/dj-xu/cloudflare-worker/.wrangler/tmp/bundle-nkkSe7/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/chilumbam/dj-xu/cloudflare-worker/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/chilumbam/dj-xu/cloudflare-worker/.wrangler/tmp/bundle-nkkSe7/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/chilumbam/dj-xu/cloudflare-worker/.wrangler/tmp/bundle-nkkSe7/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
